<!--
  History Manager for Browser Back Button and Refresh Support
  Uses google.script.history API to create history entries and handle back/forward navigation
  Uses sessionStorage to persist location across browser refresh
-->
<script>
(function() {
  'use strict';

  // Private state
  var _clientId = null;
  var _baseUrl = null;
  var _isRestoring = false;
  var _initialized = false;
  var RESTORE_FLAG_KEY = '_historyManagerRestoring';
  var LOCATION_KEY = '_ftpCurrentLocation';
  var BASE_URL_KEY = '_ftpBaseUrl';
  var LOCATION_MAX_AGE_MS = 30 * 60 * 1000; // 30 minutes - expire stale locations
  var NAV_FALLBACK_MS = 10000; // 10 seconds before showing fallback UI

  /**
   * Save the current location to sessionStorage for refresh recovery
   * @param {string} view - 'dashboard', 'tool', or 'report'
   * @param {Object} options - { toolId, page } depending on view
   */
  function saveLocation(view, options) {
    try {
      var location = {
        view: view,
        toolId: options.toolId || null,
        page: options.page || null,
        clientId: _clientId,
        timestamp: Date.now()
      };
      sessionStorage.setItem(LOCATION_KEY, JSON.stringify(location));
      console.log('[HistoryManager] Saved location:', location);
    } catch (e) {
      // sessionStorage might not be available
      console.warn('[HistoryManager] Could not save location:', e);
    }
  }

  /**
   * Get stored location from sessionStorage
   * @returns {Object|null} Stored location or null if not found/expired
   */
  function getStoredLocation() {
    try {
      var stored = sessionStorage.getItem(LOCATION_KEY);
      if (!stored) return null;

      var location = JSON.parse(stored);

      // Check if location is stale (older than 30 minutes)
      if (Date.now() - location.timestamp > LOCATION_MAX_AGE_MS) {
        console.log('[HistoryManager] Stored location expired, clearing');
        sessionStorage.removeItem(LOCATION_KEY);
        return null;
      }

      return location;
    } catch (e) {
      return null;
    }
  }

  /**
   * Clear stored location (call on logout or when appropriate)
   */
  window.clearStoredLocation = function() {
    try {
      sessionStorage.removeItem(LOCATION_KEY);
      console.log('[HistoryManager] Cleared stored location');
    } catch (e) {
      // Ignore errors
    }
  };

  /**
   * Save location for refresh recovery (global helper for tool card scripts)
   * @param {string} view - 'dashboard', 'tool', or 'report'
   * @param {string} toolId - Tool ID (e.g., 'tool1')
   * @param {number} page - Page number (for tool views)
   * @param {string} clientId - Client ID
   */
  window.saveLocationForRefresh = function(view, toolId, page, clientId) {
    try {
      sessionStorage.setItem(LOCATION_KEY, JSON.stringify({
        view: view,
        toolId: toolId || null,
        page: page || null,
        clientId: clientId || _clientId,
        timestamp: Date.now()
      }));
      console.log('[HistoryManager] Saved location for refresh:', view, toolId, page);
    } catch (e) {
      // sessionStorage might not be available
    }
  };

  /**
   * Check if two locations match
   * @param {Object} loc1
   * @param {Object} loc2
   * @returns {boolean}
   */
  function locationsMatch(loc1, loc2) {
    if (!loc1 || !loc2) return false;
    return loc1.view === loc2.view &&
           loc1.toolId === loc2.toolId &&
           loc1.page === loc2.page;
  }

  /**
   * Initialize the history manager
   * @param {string} clientId - The current client/student ID
   * @param {string} [baseUrl] - The GAS deployment base URL for fallback navigation
   */
  window.initHistoryManager = function(clientId, baseUrl) {
    if (_initialized) {
      console.log('[HistoryManager] Already initialized');
      return;
    }

    _clientId = clientId;

    // Store baseUrl for fallback navigation (persist in sessionStorage for recovery paths)
    if (baseUrl) {
      _baseUrl = baseUrl;
      try { sessionStorage.setItem(BASE_URL_KEY, baseUrl); } catch(e) {}
    } else {
      try { _baseUrl = sessionStorage.getItem(BASE_URL_KEY); } catch(e) {}
    }

    // Check if we're restoring from a back/forward navigation (flag set by previous page)
    var wasRestoring = false;
    try {
      wasRestoring = sessionStorage.getItem(RESTORE_FLAG_KEY) === 'true';
      sessionStorage.removeItem(RESTORE_FLAG_KEY); // Clear flag after reading
    } catch (e) {
      // sessionStorage might not be available
    }

    // Detect current view from DOM
    var currentView = detectCurrentView();
    console.log('[HistoryManager] Current view:', currentView.view, currentView.options);

    // Check for browser refresh: compare current view with stored location
    // Only redirect if we detect a refresh that lost the user's place
    // (i.e., they were deeper in a tool but URL loaded an earlier page)
    if (!wasRestoring) {
      var storedLocation = getStoredLocation();
      if (storedLocation && storedLocation.clientId === clientId) {
        var currentLocation = {
          view: currentView.view,
          toolId: currentView.options.toolId || null,
          page: currentView.options.page || null
        };

        // Determine if we should attempt refresh recovery
        var shouldRecover = false;

        // Case 1: Stored tool page, current is same tool but earlier page
        if (storedLocation.view === 'tool' && currentLocation.view === 'tool') {
          if (storedLocation.toolId === currentLocation.toolId &&
              storedLocation.page !== currentLocation.page &&
              storedLocation.page > currentLocation.page) {
            console.log('[HistoryManager] Refresh detected! User was on page', storedLocation.page, 'but URL loaded page', currentLocation.page);
            shouldRecover = true;
          }
        }

        // Case 2: Stored report but current is tool (same toolId)
        if (storedLocation.view === 'report' && currentLocation.view === 'tool' &&
            storedLocation.toolId === currentLocation.toolId) {
          console.log('[HistoryManager] Refresh detected! User was viewing report but URL loaded tool page');
          shouldRecover = true;
        }

        // Case 3: Stored tool/report but current is login or dashboard (URL had no params)
        // This happens when login used document.write() and URL never changed
        if ((storedLocation.view === 'tool' || storedLocation.view === 'report') &&
            (currentLocation.view === 'login' || currentLocation.view === 'dashboard')) {
          console.log('[HistoryManager] Refresh detected! User was in', storedLocation.view, 'but URL loaded', currentLocation.view);
          shouldRecover = true;
        }

        if (shouldRecover) {
          _isRestoring = true;

          if (typeof showLoading === 'function') {
            showLoading('Restoring your place...');
          }

          // Use stored clientId if current clientId is not available (e.g., on login page)
          var recoveryClientId = clientId || storedLocation.clientId;

          // Redirect based on stored view
          switch(storedLocation.view) {
            case 'tool':
              if (storedLocation.toolId && storedLocation.page && recoveryClientId) {
                loadToolPage(storedLocation.toolId, recoveryClientId, storedLocation.page);
                return; // Exit - page will reload
              }
              break;
            case 'report':
              if (storedLocation.toolId && recoveryClientId) {
                loadReport(storedLocation.toolId, recoveryClientId);
                return; // Exit - page will reload
              }
              break;
          }
        }
      }
    }

    _initialized = true;

    // Check if google.script.history API is available
    if (typeof google === 'undefined' || !google.script || !google.script.history) {
      console.warn('[HistoryManager] google.script.history API not available - back button support disabled');
      // Still save location for refresh support even without history API
      saveLocation(currentView.view, currentView.options);
      return;
    }

    try {
      // Set up the history change handler (fires on back/forward)
      google.script.history.setChangeHandler(handleHistoryChange);
      console.log('[HistoryManager] Change handler registered');

      // Push initial state for current view (if not restoring from back button)
      if (!wasRestoring) {
        console.log('[HistoryManager] Initialized with view:', currentView.view, currentView.options);
        pushAppState(currentView.view, currentView.options);
      } else {
        // After document.write() during back/forward restoration, the GAS parent
        // frame's postMessage bridge to the iframe becomes stale. Calling replace()
        // reconnects the callback channel so google.script.run callbacks work again.
        // We use replace() instead of push() to avoid duplicate history entries.
        var replaceState = {
          view: currentView.view,
          clientId: _clientId,
          toolId: currentView.options.toolId || null,
          page: currentView.options.page || null,
          timestamp: Date.now()
        };
        try {
          google.script.history.replace(replaceState, {}, '');
          console.log('[HistoryManager] Replaced state after restoration:', replaceState);
        } catch (e) {
          console.warn('[HistoryManager] Error replacing state:', e);
        }
      }
      // Always save location for refresh recovery
      saveLocation(currentView.view, currentView.options);
    } catch (e) {
      console.error('[HistoryManager] Error initializing:', e);
    }
  };

  /**
   * Push a new history state entry
   * Call this after each navigation to create a back button entry
   * @param {string} view - 'dashboard', 'tool', or 'report'
   * @param {Object} options - { toolId, page } depending on view
   */
  window.pushAppState = function(view, options) {
    // Check if API is available
    if (typeof google === 'undefined' || !google.script || !google.script.history) {
      return;
    }

    // Do not push state if we are currently restoring from back button
    if (_isRestoring) {
      console.log('[HistoryManager] Skipping pushState during restoration');
      return;
    }

    options = options || {};
    var state = {
      view: view,
      clientId: _clientId,
      toolId: options.toolId || null,
      page: options.page || null,
      timestamp: Date.now()
    };

    try {
      console.log('[HistoryManager] Pushing state:', state);
      google.script.history.push(state, {}, '');
    } catch (e) {
      console.error('[HistoryManager] Error pushing state:', e);
    }
  };

  /**
   * Handle browser back/forward button press
   * @param {Object} e - Event with state and location
   */
  function handleHistoryChange(e) {
    var state = e.state;
    console.log('[HistoryManager] History change detected:', state);

    // No state means user went back before our first push - go to dashboard
    if (!state || !state.view) {
      console.log('[HistoryManager] No state, defaulting to dashboard');
      state = { view: 'dashboard', clientId: _clientId };
    }

    _isRestoring = true;
    var clientId = state.clientId || _clientId;

    // Show loading IMMEDIATELY for instant feedback
    if (typeof showLoading === 'function') {
      showLoading('Navigating...');
    }

    // Navigation helper - called after save completes (or immediately if no form)
    function navigateToState() {
      switch(state.view) {
        case 'dashboard':
          loadDashboard(clientId);
          break;
        case 'tool':
          if (state.toolId && state.page) {
            loadToolPage(state.toolId, clientId, state.page);
          } else {
            console.warn('[HistoryManager] Tool state missing toolId or page, going to dashboard');
            loadDashboard(clientId);
          }
          break;
        case 'report':
          if (state.toolId) {
            loadReport(state.toolId, clientId);
          } else {
            console.warn('[HistoryManager] Report state missing toolId, going to dashboard');
            loadDashboard(clientId);
          }
          break;
        default:
          console.warn('[HistoryManager] Unknown view:', state.view);
          loadDashboard(clientId);
      }
    }

    // Save form data FIRST, then navigate after save completes
    // This prevents concurrent google.script.run calls which cause GAS to
    // reload the iframe when document.write() destroys the pending callback
    saveCurrentFormDataAsync(navigateToState);
  }

  /**
   * Detect the current view from DOM structure
   * @returns {Object} { view: string, options: Object }
   */
  function detectCurrentView() {
    // Check for multi-page tool form (e.g., tool1Page2Form)
    var form = document.querySelector('form[id*="Page"][id*="Form"]');
    if (form) {
      var match = form.id.match(/^(tool\d+)Page(\d+)/);
      if (match) {
        return {
          view: 'tool',
          options: { toolId: match[1], page: parseInt(match[2]) }
        };
      }
    }

    // Check for calculator tool containers (Tool 4, Tool 6, Tool 8)
    var tool4Container = document.querySelector('.tool4-container, #tool4-app');
    if (tool4Container) {
      return { view: 'tool', options: { toolId: 'tool4', page: 1 }};
    }

    var tool6Container = document.querySelector('.tool6-container, #tool6-app');
    if (tool6Container) {
      return { view: 'tool', options: { toolId: 'tool6', page: 1 }};
    }

    var tool8Container = document.querySelector('.tool8-container');
    if (tool8Container) {
      return { view: 'tool', options: { toolId: 'tool8', page: 1 }};
    }

    // Check for report page
    var reportContainer = document.querySelector('.report-container, .report-wrapper, [class*="report"]');
    if (reportContainer) {
      // Try to extract toolId from report
      var toolIdMeta = document.querySelector('meta[name="tool-id"]');
      var toolId = toolIdMeta ? toolIdMeta.content : null;
      return { view: 'report', options: { toolId: toolId }};
    }

    // Check for login page (has loginForm or loginPage id)
    var loginForm = document.querySelector('#loginForm, #loginPage');
    if (loginForm) {
      return { view: 'login', options: {} };
    }

    // Default to dashboard
    return { view: 'dashboard', options: {} };
  }

  /**
   * Save current form data before navigating away (prevents data loss)
   * @param {Function} callback - Called after save completes (or immediately if no form)
   */
  function saveCurrentFormData(callback) {
    var forms = document.querySelectorAll('form[id*="Page"]');
    if (forms.length === 0) {
      callback();
      return;
    }

    var form = forms[0];
    var match = form.id.match(/^(tool\d+)/);
    if (!match) {
      callback();
      return;
    }

    var toolId = match[1];
    var formData = new FormData(form);
    var data = Object.fromEntries(formData.entries());

    // Only save if there is actual data
    if (Object.keys(data).length === 0) {
      callback();
      return;
    }

    console.log('[HistoryManager] Saving form data for', toolId);

    google.script.run
      .withSuccessHandler(function() {
        console.log('[HistoryManager] Form data saved');
        callback();
      })
      .withFailureHandler(function(error) {
        console.warn('[HistoryManager] Form save failed:', error);
        callback(); // Continue navigation even if save fails
      })
      .saveToolPageData(toolId, data);
  }

  /**
   * Save current form data, then call callback when done
   * Callback is always called (on success, failure, or if no form found)
   * @param {Function} callback - Called after save completes or immediately if no form
   */
  function saveCurrentFormDataAsync(callback) {
    // Safety guard: ensure callback is only called once
    var callbackFired = false;
    function safeCallback() {
      if (callbackFired) return;
      callbackFired = true;
      if (safetyTimer) clearTimeout(safetyTimer);
      callback();
    }

    // Safety timeout: proceed with navigation without waiting for save callback.
    // The save completes on the server regardless - we just cannot reliably
    // receive the callback after document.write() page replacements.
    // Data save is best-effort during back/forward navigation.
    var safetyTimer = null;
    function startSafetyTimeout() {
      safetyTimer = setTimeout(function() {
        console.log('[HistoryManager] Proceeding with navigation (save continues in background)');
        safeCallback();
      }, 500);
    }

    // Try multi-page tool forms first (Tool 1/2/3/5/7)
    var forms = document.querySelectorAll('form[id*="Page"]');
    if (forms.length > 0) {
      var form = forms[0];
      var match = form.id.match(/^(tool\d+)/);
      if (match) {
        var toolId = match[1];
        var formData = new FormData(form);
        var data = Object.fromEntries(formData.entries());

        if (Object.keys(data).length > 0) {
          console.log('[HistoryManager] Saving form data for', toolId);
          startSafetyTimeout();
          google.script.run
            .withSuccessHandler(function() {
              console.log('[HistoryManager] Form data saved');
              safeCallback();
            })
            .withFailureHandler(function(error) {
              console.warn('[HistoryManager] Form save failed:', error);
              safeCallback();
            })
            .saveToolPageData(toolId, data);
          return;
        }
        safeCallback();
        return;
      }
    }

    // Try Tool 4 calculator (preSurveyForm)
    var tool4Form = document.getElementById('preSurveyForm');
    var tool4Container = document.querySelector('.tool4-container');
    if (tool4Form && tool4Container) {
      startSafetyTimeout();
      saveTool4DataAsync(safeCallback);
      return;
    }

    // Try Tool 6 calculator (questionnaireForm)
    var tool6Form = document.getElementById('questionnaireForm');
    var tool6Container = document.querySelector('.tool6-container');
    if (tool6Form && tool6Container) {
      startSafetyTimeout();
      saveTool6DataAsync(safeCallback);
      return;
    }

    // Tool 8 calculator - no persistent draft to save (state is ephemeral,
    // pre-populated from upstream data on each visit). Just navigate.
    var tool8Container = document.querySelector('.tool8-container');
    if (tool8Container) {
      safeCallback();
      return;
    }

    // No form found - navigate immediately
    safeCallback();
  }

  /**
   * Save Tool 4 calculator data, then call callback when done
   * @param {Function} callback - Called after save completes or immediately if no data
   */
  function saveTool4DataAsync(callback) {
    var form = document.getElementById('preSurveyForm');
    if (!form) { callback(); return; }

    // Collect form data
    var data = {
      client: _clientId,
      monthlyIncome: getInputValue('monthlyIncome'),
      monthlyEssentials: getInputValue('monthlyEssentials'),
      totalDebt: getInputValue('totalDebt'),
      emergencyFund: getInputValue('emergencyFund'),
      debtInterest: getInputValue('debtInterest'),
      enjoymentSpending: getInputValue('enjoymentSpending'),
      satisfaction: getInputValue('satisfaction'),
      discipline: getInputValue('discipline'),
      selectedPriority: getInputValue('selectedPriority'),
      goalTimeline: getInputValue('goalTimeline')
    };

    // Only save if we have meaningful data
    if (!data.monthlyIncome && !data.monthlyEssentials) {
      console.log('[HistoryManager] Tool 4 form empty, skipping save');
      callback();
      return;
    }

    console.log('[HistoryManager] Saving Tool 4 data');
    google.script.run
      .withSuccessHandler(function() {
        console.log('[HistoryManager] Tool 4 data saved');
        callback();
      })
      .withFailureHandler(function(error) {
        console.warn('[HistoryManager] Tool 4 save failed:', error);
        callback(); // Continue navigation even if save fails
      })
      .savePreSurvey(_clientId, data);
  }

  /**
   * Save Tool 6 calculator data, then call callback when done
   * @param {Function} callback - Called after save completes or immediately if no data
   */
  function saveTool6DataAsync(callback) {
    var form = document.getElementById('questionnaireForm');
    if (!form) { callback(); return; }

    // Collect all form inputs (Tool 6 has many dynamic fields)
    var data = { client: _clientId };

    // Get all inputs from questionnaireForm
    var formData = new FormData(form);
    for (var pair of formData.entries()) {
      data[pair[0]] = pair[1];
    }

    // Also get backup question inputs if they exist
    var backupInputs = document.querySelectorAll('[id^="backup_"], [id^="a1_"], [id^="a2_"], [id^="a3_"], [id^="a4_"], [id^="a5_"], [id^="a6_"]');
    backupInputs.forEach(function(input) {
      if (input.type === 'radio' || input.type === 'checkbox') {
        if (input.checked) {
          data[input.id] = input.value;
        }
      } else if (input.tagName === 'SELECT') {
        data[input.id] = input.value;
      } else {
        data[input.id] = input.value;
      }
    });

    // Only save if we have meaningful data
    var hasData = Object.keys(data).some(function(key) {
      return key !== 'client' && data[key];
    });

    if (!hasData) {
      console.log('[HistoryManager] Tool 6 form empty, skipping save');
      callback();
      return;
    }

    console.log('[HistoryManager] Saving Tool 6 data');
    google.script.run
      .withSuccessHandler(function() {
        console.log('[HistoryManager] Tool 6 data saved');
        callback();
      })
      .withFailureHandler(function(error) {
        console.warn('[HistoryManager] Tool 6 save failed:', error);
        callback(); // Continue navigation even if save fails
      })
      .savePreSurveyTool6(_clientId, data);
  }

  /**
   * Helper to safely get input value by ID
   */
  function getInputValue(id) {
    var el = document.getElementById(id);
    if (!el) return '';
    if (el.type === 'radio' || el.type === 'checkbox') {
      return el.checked ? el.value : '';
    }
    return el.value || '';
  }

  /**
   * Build a fallback URL for manual navigation
   * @param {string} route - Route name (e.g., 'dashboard', 'tool1')
   * @param {string} clientId
   * @param {Object} [params] - Additional URL params
   * @returns {string|null} Full URL or null if baseUrl unavailable
   */
  function buildFallbackUrl(route, clientId, params) {
    var url = _baseUrl;
    if (!url) {
      try { url = sessionStorage.getItem(BASE_URL_KEY); } catch(e) {}
    }
    if (!url) return null;

    var queryParams = '?route=' + encodeURIComponent(route) + '&client=' + encodeURIComponent(clientId);
    if (params) {
      for (var key in params) {
        if (params.hasOwnProperty(key) && params[key] != null) {
          queryParams += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }
      }
    }
    return url + queryParams;
  }

  /**
   * Show a clickable fallback button when google.script.run callback times out.
   * Uses an <a target="_top"> link so the user's click provides the
   * user-activation required by the GAS iframe sandbox for top-frame navigation.
   * @param {string} route - Route name
   * @param {string} clientId
   * @param {Object} [params] - Additional URL params
   */
  function showFallbackButton(route, clientId, params) {
    var url = buildFallbackUrl(route, clientId, params);
    if (!url) {
      _isRestoring = false;
      if (typeof hideLoading === 'function') hideLoading();
      alert('Navigation error. Please refresh the page.');
      return;
    }

    console.log('[HistoryManager] Showing fallback button for:', url);

    // Remove any existing loading overlay
    if (typeof hideLoading === 'function') hideLoading();

    // Create a clickable overlay â€” target="_top" navigates the parent frame
    // and the user's click provides the activation the sandbox requires
    var overlay = document.createElement('div');
    overlay.id = 'historyManagerFallback';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;' +
      'background:rgba(0,0,0,0.85);z-index:99999;display:flex;align-items:center;' +
      'justify-content:center;';
    overlay.innerHTML = '<div style="background:#fff;padding:32px 40px;border-radius:12px;' +
      'text-align:center;max-width:420px;font-family:sans-serif;">' +
      '<p style="margin:0 0 8px;font-size:18px;font-weight:600;color:#333;">Loading is taking longer than expected</p>' +
      '<p style="margin:0 0 20px;font-size:14px;color:#666;">Click the button below to continue.</p>' +
      '<a href="' + url + '" target="_top" style="display:inline-block;padding:12px 32px;' +
      'background:#4285f4;color:#fff;text-decoration:none;border-radius:6px;font-size:16px;' +
      'font-weight:500;">Continue</a></div>';

    document.body.appendChild(overlay);
  }

  /**
   * Load dashboard page
   * @param {string} clientId
   */
  function loadDashboard(clientId) {
    // Loading already shown by handleHistoryChange
    var handled = false;

    // Safety fallback: if google.script.run callback never arrives
    // (stale postMessage bridge after document.write), show clickable button
    var fallbackTimer = setTimeout(function() {
      if (!handled) {
        handled = true;
        console.warn('[HistoryManager] google.script.run callback timeout - showing fallback button');
        saveLocation('dashboard', {});
        showFallbackButton('dashboard', clientId);
      }
    }, NAV_FALLBACK_MS);

    google.script.run
      .withSuccessHandler(function(html) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        // Save destination location BEFORE writing (for refresh recovery)
        saveLocation('dashboard', {});
        writeAndFinishRestore(html);
      })
      .withFailureHandler(function(error) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        handleNavError(error, 'dashboard');
      })
      .getDashboardPage(clientId);
  }

  /**
   * Load a specific tool page
   * @param {string} toolId - e.g., 'tool1'
   * @param {string} clientId
   * @param {number} page - Page number
   */
  function loadToolPage(toolId, clientId, page) {
    if (typeof showLoading === 'function') {
      showLoading('Loading ' + toolId.replace('tool', 'Tool ') + ' Page ' + page);
    }

    var handled = false;
    var fallbackTimer = setTimeout(function() {
      if (!handled) {
        handled = true;
        console.warn('[HistoryManager] google.script.run callback timeout - showing fallback button');
        saveLocation('tool', { toolId: toolId, page: page });
        showFallbackButton(toolId, clientId, { page: page });
      }
    }, NAV_FALLBACK_MS);

    google.script.run
      .withSuccessHandler(function(html) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        // Remove fallback button if it was shown (race condition guard)
        var fb = document.getElementById('historyManagerFallback');
        if (fb) fb.remove();
        // Save destination location BEFORE writing (for refresh recovery)
        saveLocation('tool', { toolId: toolId, page: page });
        writeAndFinishRestore(html);
      })
      .withFailureHandler(function(error) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        handleNavError(error, 'tool page');
      })
      .getToolPageHtml(toolId, clientId, page);
  }

  /**
   * Load a report page
   * @param {string} toolId - e.g., 'tool1'
   * @param {string} clientId
   */
  function loadReport(toolId, clientId) {
    if (typeof showLoading === 'function') {
      showLoading('Loading Report');
    }

    var handled = false;
    var fallbackTimer = setTimeout(function() {
      if (!handled) {
        handled = true;
        console.warn('[HistoryManager] google.script.run callback timeout - showing fallback button');
        saveLocation('report', { toolId: toolId });
        showFallbackButton(toolId + '_report', clientId);
      }
    }, NAV_FALLBACK_MS);

    google.script.run
      .withSuccessHandler(function(html) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        // Save destination location BEFORE writing (for refresh recovery)
        saveLocation('report', { toolId: toolId });
        writeAndFinishRestore(html);
      })
      .withFailureHandler(function(error) {
        if (handled) return;
        handled = true;
        clearTimeout(fallbackTimer);
        handleNavError(error, 'report');
      })
      .getReportPage(clientId, toolId);
  }

  /**
   * Write HTML to document and finish restoration
   * @param {string} html
   */
  function writeAndFinishRestore(html) {
    if (!html) {
      handleNavError({ message: 'Server returned empty response' }, 'page');
      return;
    }

    // Set flag so the NEW page knows not to push duplicate state
    try {
      sessionStorage.setItem(RESTORE_FLAG_KEY, 'true');
    } catch (e) {
      // sessionStorage might not be available
    }

    document.open();
    document.write(html);
    document.close();
    window.scrollTo(0, 0);
    // Note: The NEW page will check sessionStorage for RESTORE_FLAG_KEY
    // and skip pushing duplicate state
  }

  /**
   * Handle navigation errors
   * @param {Object} error
   * @param {string} pageType
   */
  function handleNavError(error, pageType) {
    _isRestoring = false;

    if (typeof hideLoading === 'function') {
      hideLoading();
    }

    console.error('[HistoryManager] Error loading ' + pageType + ':', error);
    alert('Error loading ' + pageType + ': ' + (error.message || error));
  }

  /**
   * Auto-recovery for login page
   * Runs automatically when history-manager loads on a page without initHistoryManager being called
   * This handles the case where user refreshes and gets sent back to login
   */
  function attemptAutoRecovery() {
    // Only run if we have not been initialized (login page does not call initHistoryManager)
    if (_initialized) return;

    // Check if we are on the login page
    var loginForm = document.querySelector('#loginForm, #loginPage');
    if (!loginForm) return;

    console.log('[HistoryManager] Auto-recovery check on login page');

    // Check for stored location
    var storedLocation = getStoredLocation();
    if (!storedLocation || !storedLocation.clientId) {
      console.log('[HistoryManager] No stored location or clientId for recovery');
      return;
    }

    // Only recover if stored view was tool, report, or dashboard (not login)
    if (storedLocation.view === 'login') {
      console.log('[HistoryManager] Stored view is not recoverable:', storedLocation.view);
      return;
    }

    console.log('[HistoryManager] Auto-recovering from login to', storedLocation.view);
    _isRestoring = true;

    if (typeof showLoading === 'function') {
      showLoading('Restoring your place...');
    }

    // Redirect based on stored view
    switch(storedLocation.view) {
      case 'tool':
        if (storedLocation.toolId && storedLocation.page) {
          loadToolPage(storedLocation.toolId, storedLocation.clientId, storedLocation.page);
        }
        break;
      case 'report':
        if (storedLocation.toolId) {
          loadReport(storedLocation.toolId, storedLocation.clientId);
        }
        break;
      case 'dashboard':
        loadDashboard(storedLocation.clientId);
        break;
    }
  }

  // Run auto-recovery when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attemptAutoRecovery);
  } else {
    // DOM already loaded, run immediately
    attemptAutoRecovery();
  }

})();
</script>
